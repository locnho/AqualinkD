
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <stdlib.h>

#include "aq_serial.h"
#include "aqualink.h"
#include "serialadapter.h"
#include "packetLogger.h"
#include "color_lights.h"
#include "allbutton.h"

#define RSSA_QLEN 40

unsigned char _rssa_queue[RSSA_QLEN][4];
int _rssa_q_length = 0;
bool _rssa_last_was_queue = false;
//int _rssa_position = 0;

unsigned char probe_reply[] = {0x00,0x01,0x00,0x05};
unsigned char rssa_null[]   = {0x00,0x01,0x00,0x00};

unsigned char getUnits[] = {0x00,0x01,RS_SA_UNITS,0x05};
unsigned char getPoolSP[] = {0x00,0x01,RS_SA_POOLSP,0x05};
unsigned char getPoolSP2[] = {0x00,0x01,RS_SA_POOLSP2,0x05};
unsigned char getSpaSP[] = {0x00,0x01,RS_SA_SPASP,0x05};
//unsigned char getModel[] = {0x00,0x01,RS_SA_MODEL,0x05};


unsigned char getAux12[] = {0x00,0x01,0x00,RS_SA_AUX12};
unsigned char getAux13[] = {0x00,0x01,0x00,RS_SA_AUX13};
unsigned char getAux14[] = {0x00,0x01,0x00,RS_SA_AUX14};
unsigned char getAux15[] = {0x00,0x01,0x00,RS_SA_AUX15};


// processLEDstate exists in allbutton.c
//void processLEDstate(struct aqualinkdata *aqdata, unsigned char *packet, logmask_t from);
void processRSSALEDstate(struct aqualinkdata *aqdata, unsigned char *packet)
{
  processLEDstate(aqdata, packet, RSSA_LOG);
}


bool push_rssa_cmd(unsigned char *cmd) {
  if (_rssa_q_length >= RSSA_QLEN ) {
    LOG(RSSA_LOG,LOG_ERR, "Queue overflow, last command ignored!\n");
    return false;
  }

  memcpy(_rssa_queue[_rssa_q_length++], cmd, 4);

  LOG(RSSA_LOG,LOG_DEBUG, "Added to message queue, position %d 0x%02hhx|0x%02hhx|0x%02hhx|0x%02hhx\n",_rssa_q_length-1,_rssa_queue[_rssa_q_length-1][0],_rssa_queue[_rssa_q_length-1][1],_rssa_queue[_rssa_q_length-1][2],_rssa_queue[_rssa_q_length-1][3]);
  return true;
}

unsigned char *get_rssa_cmd(unsigned char source_message_type) {

  _rssa_last_was_queue = false;

//startInlineSerialDebug();

  // NSF Need to check for error on reply message //0x013|0x02 (I believe)
  // Maybe put it in main loop process_rssadapter_packet()

  if ( source_message_type == 0x07 )
    LOG(RSSA_LOG,LOG_DEBUG, "Replying to 2nd command sequence\n");

  if (source_message_type == CMD_PROBE)
    return probe_reply;
  else if (source_message_type != CMD_STATUS && source_message_type != 0x07) // 0x07 is second part of set message
    return rssa_null; // Only send command on status messages.
  else  {
    if (_rssa_q_length > 0) {
      LOG(RSSA_LOG,LOG_DEBUG, "Pull from message queue, length %d 0x%02hhx|0x%02hhx|0x%02hhx|0x%02hhx\n",_rssa_q_length,_rssa_queue[0][0],_rssa_queue[0][1],_rssa_queue[0][2],_rssa_queue[0][3]);
      _rssa_last_was_queue = true;
      return _rssa_queue[0];
    }   
  }

  return rssa_null;
}

void remove_rssa_cmd() {

//stopInlineDebug();

  if (_rssa_q_length > 0 && _rssa_last_was_queue == true) {
    LOG(RSSA_LOG,LOG_DEBUG, "Remove from message queue, length %d\n",_rssa_q_length-1);
    memmove(&_rssa_queue[0], &_rssa_queue[1], (sizeof(unsigned char) * 4) * _rssa_q_length);
    _rssa_q_length--;
  }
}

void queue_aqualink_rssadapter_setpoint(unsigned char typeID, int val) {
  unsigned char readySP[] = {0x00,0x01,typeID,0x35};
  unsigned char setSP[] = {0x00,0x01,0x00,(unsigned char)val};

  push_rssa_cmd(readySP);
  push_rssa_cmd(setSP);
}

/* NSF Need to delete this and use aqbuttonp[].rssd_code */
unsigned char RSSAdevID(int bIndex) {
  // pool = 0; spa = 1; aux1 = 2 etc
  // rssa pool / spa are different.  aux1 = 21 (0x15) then goes up from their in order.

  // NSF Pool Heat / Spa Heat / Solar Heater are also out of order. But have not accounted for that.
  // It might be better to ass the RSS_ID's to the buttons in aq_panel in the future if we expand using
  // this protocol.
  // look at AllButton2RSsrialAdapter function at bottom of file.
  if (bIndex==0)
    return RS_SA_PUMP;
  else if (bIndex==1)
    return RS_SA_SPA;
  else if (bIndex >= 2 && bIndex <= 16) {
    // aux1 = index 2  & aux1 = 0x15.  So add inxed to 0x13
    return (unsigned char)0x13 + bIndex;
  }

  return 0x00;
}


void rssadapter_device_state(const unsigned char devID, const unsigned char state) {
  unsigned char setDev[] = {0x00,0x01,state,devID};
  push_rssa_cmd(setDev);
}
/*
void rssadapter_device_off(unsigned char devID) {
  unsigned char setDev[] = {0x00,0x01,0x80,devID};
  push_rssa_cmd(setDev);
}
*/

void set_aqualink_rssadapter_aux_extended_state(const aqkey *button, const unsigned char state) {
  
  LOG(RSSA_LOG,LOG_DEBUG, "Sending 0x%02hhx to %s\n",state, button->label);

  rssadapter_device_state(button->rssd_code, state); // Set state
  rssadapter_device_state(button->rssd_code, 0x00); // 0x00 means Get curent state (for color lights the return state is 0)
}

void set_aqualink_rssadapter_aux_state(const aqkey *button, bool turnOn)
{
  LOG(RSSA_LOG,LOG_DEBUG, "Turning button %s %s\n",button->label,(turnOn?"On":"Off"));

  rssadapter_device_state( button->rssd_code, (turnOn?RS_SA_ON:RS_SA_OFF) );

  // NOTE.  If we turn off AUX1 and get this return HEX: 0x10|0x02|0x48|0x13|0x02|0x00|0x0e|0x15|0x92|0x10|0x03|
  // The 0x0e means some from of oiption is set (ie cleaner).  Maybe try to turn cleaner off instead 0x15 is aux1 1x10 is cleaner.
}


/*
void set_aqualink_rssadapter_aux_state(int buttonIndex, bool turnOn)
{
  LOG(RSSA_LOG,LOG_DEBUG, "Turning button %d %s\n",buttonIndex,(turnOn?"On":"Off"));

  rssadapter_device_state( RSSAdevID(buttonIndex), (turnOn?RS_SA_ON:RS_SA_OFF) );
}
*/
void increase_aqualink_rssadapter_pool_setpoint(char *args, struct aqualinkdata *aqdata) {
  int val = atoi(args);
  val = setpoint_check(POOL_HTR_SETPOINT, aqdata->pool_htr_set_point + val, aqdata);

  LOG(RSSA_LOG,LOG_DEBUG, "Increasing pool heater from %d to %d\n",aqdata->pool_htr_set_point,val);

  queue_aqualink_rssadapter_setpoint(RS_SA_POOLSP, val);
}

void increase_aqualink_rssadapter_spa_setpoint(char *args, struct aqualinkdata *aqdata) {
  int val = atoi(args);

  val = setpoint_check(SPA_HTR_SETPOINT, aqdata->spa_htr_set_point + val, aqdata);

  LOG(RSSA_LOG,LOG_DEBUG, "Increasing spa heater from %d to %d\n",aqdata->spa_htr_set_point,val);

  queue_aqualink_rssadapter_setpoint( (isSINGLE_DEV_PANEL?RS_SA_POOLSP2:RS_SA_SPASP), val);
}

void set_aqualink_rssadapter_pool_setpoint(char *args, struct aqualinkdata *aqdata) {
  int val = atoi(args);
  val = setpoint_check(POOL_HTR_SETPOINT, val, aqdata);

  LOG(RSSA_LOG,LOG_DEBUG, "Setting pool heater to %d\n",val);

  queue_aqualink_rssadapter_setpoint(RS_SA_POOLSP, val);
  /*
  unsigned char readyPoolSP[] = {0x00,0x01,RS_SA_POOLSP,0x35};
  unsigned char setPoolSP[] = {0x00,0x01,0x00,(unsigned char)val};

  push_rssa_cmd(readyPoolSP);
  push_rssa_cmd(setPoolSP);
  */
}

void set_aqualink_rssadapter_spa_setpoint(char *args, struct aqualinkdata *aqdata) {
  int val = atoi(args);

  val = setpoint_check(SPA_HTR_SETPOINT, val, aqdata);

  queue_aqualink_rssadapter_setpoint( (isSINGLE_DEV_PANEL?RS_SA_POOLSP2:RS_SA_SPASP), val);
/*
  if (isSINGLE_DEV_PANEL) {
    LOG(RSSA_LOG,LOG_DEBUG, "Setting pool2 heater to %d\n",val);
    unsigned char readySpaSP[] = {0x00,0x01,RS_SA_POOLSP2,0x35};
    push_rssa_cmd(readySpaSP);
  } else {
    LOG(RSSA_LOG,LOG_DEBUG, "Setting spa heater to %d\n",val);
    unsigned char readySpaSP[] = {0x00,0x01,RS_SA_SPASP,0x35};
    push_rssa_cmd(readySpaSP);
  }

  unsigned char setSpaSP[] = {0x00,0x01,0x00,(unsigned char)val};
  push_rssa_cmd(setSpaSP);
*/
}


#ifdef CLIGHT_PANEL_FIX
/* This is to overcome Jandy bug where panel doesn;t show the state of color light */
void get_aqualink_rssadapter_button_status(aqkey *button)
{
  if (button->rssd_code != NUL)
    rssadapter_device_state(button->rssd_code, 0x00);
}
void get_aqualink_rssadapter_colorlight_statuses(struct aqualinkdata *aqdata)
{
  for (int i=0; i < aqdata->num_lights; i++) {
    if (aqdata->lights[i].lightType != LC_PROGRAMABLE ) {
      // LC_PROGRAMABLE is aqualinkd to set, so works as normal button
      rssadapter_device_state(aqdata->lights[i].button->rssd_code, 0x00); // 0x00 meand Get curent state
    }
  }
}
#endif

void get_aqualink_rssadapter_setpoints() {
  //push_rssa_cmd(getModel);
  push_rssa_cmd(getUnits);
  push_rssa_cmd(getPoolSP);
  if (!isSINGLE_DEV_PANEL)
    push_rssa_cmd(getSpaSP);
  else
    push_rssa_cmd(getPoolSP2);
}

// Return true if we change the state.
bool setLEDstate( aqled *led, unsigned char state, struct aqualinkdata *aqdata)
{
  if (state == 0x00) {
    if (led->state != OFF) {
      led->state = OFF;
      return true;
    }
  } else if (state == 0x01) {
    if (led->state != ON) {
      led->state = ON;
      return true;
    }
  }
  // Should also add FLASH and ENABLE.

  //_aqualink_data.aqbuttons[13].led->state = OFF;
  //
  return false;
}

bool process_rssadapter_packet(unsigned char *packet, int length, struct aqualinkdata *aqdata) {
//RSSA_LOG
  bool rtn = false;
  static int cnt=-5;
  cnt++;
  //char buff[1024];
  
  //LOG(RSSA_LOG,LOG_DEBUG, " Received message\n");
  //debuglogPacket(RSSA_LOG, packet, length, true);
#ifdef CLIGHT_PANEL_FIX 
  if ( (cnt % 10 == 0) || cnt == 0 ) { // NSF Change to 20 and 1
    get_aqualink_rssadapter_colorlight_statuses(aqdata);
  }
#endif
  if (cnt == 0 || cnt >= 100) {
    LOG(RSSA_LOG,LOG_INFO, "Queue device update requests\n");

    if (cnt == 0) {
      // The below inturn calls get_aqualink_rssadapter_setpoints()
      // But do it here as it's the first init, cnt=0 will only happen once  
      queueGetProgramData(RSSADAPTER, aqdata);
    } else {
      push_rssa_cmd(getPoolSP);
    
      if (!isSINGLE_DEV_PANEL)
        push_rssa_cmd(getSpaSP);
      else
        push_rssa_cmd(getPoolSP2);
 // No status LED's for these, so get them on a poll cycle
      if ( PANEL_SIZE() >= 16 ) {
        push_rssa_cmd(getAux12);
        push_rssa_cmd(getAux13);
        push_rssa_cmd(getAux14);
        push_rssa_cmd(getAux15);
      }

    }
    cnt = 0;
  }

  if (packet[PKT_CMD] == CMD_PROBE) {
    LOG(RSSA_LOG,LOG_DEBUG, "Probe received, will queue device update shortly\n");
    //queueGetProgramData(RSSADAPTER, aqdata);
    cnt=-5; // Connection reset, so queue the status update
  
  } else if (packet[PKT_CMD] == CMD_STATUS) {
    // This is identical to allbutton status packet.
    //LOG(RSSA_LOG,LOG_DEBUG, "RS Received STATUS length %d.\n", length);
    //debuglogPacket(RSSA_LOG, packet, length, true, true);
    processRSSALEDstate(aqdata, packet);
  } else if (packet[PKT_CMD] == 0x13) {
    //beautifyPacket(buff, packet, length);
    //LOG(RSSA_LOG,LOG_DEBUG, "%s", buff);
    //LOG(RSSA_LOG,LOG_DEBUG,"  Command 0x%02hhx = |0x%02hhx|0x%02hhx|0x%02hhx  %d|%d|%d\n", packet[4], packet[5], packet[6], packet[7], packet[5], packet[6], packet[7]);
    
    
    // This is a failuer reply to setpoint 0x10|0x02|0x48|0x13|0x02|0x00|0x10|0x00|0x7f|0x10|0x03|
    // Rather than check all, just check 0x02 and checksum sin't I'm not sure 0x10 means faiure without 0x00 around it.
    if (packet[4] == 0x02 && packet[8] == 0x7f) {
      LOG(RSSA_LOG,LOG_ERR,"Last command failed\n");
    }
    if (packet[4] == RS_SA_MODEL) {
      LOG(RSSA_LOG,LOG_INFO,"Panel Model 0x%02hhx|0x%02hhx|0x%02hhx\n",packet[5],packet[6],packet[7]);
    } else if (packet[4] == RS_SA_UNITS) {
      if (packet[6] == 0x01) {
        LOG(RSSA_LOG,LOG_INFO,"Units are Deg C\n");
        SET_IF_CHANGED(aqdata->temp_units, CELSIUS, aqdata->is_dirty);
        rtn |= true;
      } else if (packet[6] == 0x00) {
        LOG(RSSA_LOG,LOG_INFO,"Units are Deg F\n");
        SET_IF_CHANGED(aqdata->temp_units, FAHRENHEIT, aqdata->is_dirty);
        rtn |= true;
      } else {
        LOG(RSSA_LOG,LOG_ERR,"Units are Unknown\n");
      }
    } else if (packet[4] == RS_SA_POOLSP) {
      LOG(RSSA_LOG,LOG_INFO,"Pool SP is %d\n", packet[6]);
      SET_IF_CHANGED(aqdata->pool_htr_set_point, (int) packet[6], aqdata->is_dirty);
      rtn |= true;
    } else if (packet[4] == RS_SA_SPASP) {
      LOG(RSSA_LOG,LOG_INFO,"Spa SP is %d\n", packet[6]);
      SET_IF_CHANGED(aqdata->spa_htr_set_point, (int) packet[6], aqdata->is_dirty);
      rtn |= true;
    } else if (packet[4] == RS_SA_POOLSP2) {
      LOG(RSSA_LOG,LOG_INFO,"Pool SP2 is %d\n", packet[6]);
      SET_IF_CHANGED(aqdata->spa_htr_set_point, (int) packet[6], aqdata->is_dirty);
      rtn |= true;
    } else if (packet[4] == 0x03 || packet[4] == 0x02) { // 03 reply from query state, 02 reply from set state
      // These are device status messages

      for (int i=0; i < aqdata->num_lights; i++) {
        if (aqdata->lights[i].lightType != LC_PROGRAMABLE && 
            aqdata->lights[i].button->rssd_code == packet[7] ) {
         
          // CHANGE TO DEBUG BEFORE RELEASE
          if (aqdata->lights[i].lightType == LC_DIMMER || aqdata->lights[i].lightType == LC_DIMMER2) {
            LOG(RSSA_LOG,LOG_DEBUG,"DimmerLight '%s' is %s, rawvalue 0x%02hhx  value '%d'%%\n",
                                  aqdata->lights[i].button->label,
                                  packet[6]==0x00?"OFF":"ON",
                                  packet[6],
                                  packet[6]==0x00?0:(packet[6] - RSSD_DIMMER_LIGHT_OFFSET));
          }else{
            LOG(RSSA_LOG,LOG_DEBUG,"ColorLight '%s' is %s 0x%02hhx  value name '%s'\n",
                                  aqdata->lights[i].button->label,
                                  packet[6]==0x00?"OFF":"ON",
                                  packet[6],
                                  packet[6]==0x00?"--":light_mode_name( aqdata->lights[i].lightType,(packet[6] - RSSD_COLOR_LIGHT_OFFSET), RSSADAPTER) );
          } 

          SET_IF_CHANGED(aqdata->lights[i].RSSDstate, (packet[6]==0x00?OFF:ON), aqdata->is_dirty);
#ifdef CLIGHT_PANEL_FIX 
          // Set LED to the correct state, but only print warning if light is on and panel states off.
          if (aqdata->lights[i].RSSDstate == ON && aqdata->lights[i].button->led->state == OFF) {
            // 0x00 is off, 0x01 is usually on, but get 0x44 for color light 0x4e=gemstone, 0x41=vodo
            LOG(RSSA_LOG,LOG_DEBUG,"ColorLight '%s' is out of sync with panel, light is '%s', panel states '%s', Fixed Jany bug!\n",
                                     aqdata->lights[i].button->label,
                                     packet[6]==0x00?"OFF":"ON",
                                     aqdata->lights[i].button->led->state==OFF?"OFF":"ON");
          }
          SET_IF_CHANGED(aqdata->lights[i].button->led->state, aqdata->lights[i].RSSDstate, aqdata->is_dirty);
#endif 
          switch(aqdata->lights[i].lightType) {
            case LC_DIMMER:
              rtn |= set_currentlight_value(&aqdata->lights[i], (packet[6] - RSSD_DIMMER_LIGHT_OFFSET) / 25);
            break;
            case LC_DIMMER2:
              rtn |= set_currentlight_value(&aqdata->lights[i], (packet[6] - RSSD_DIMMER_LIGHT_OFFSET));
            break;
            default:
              rtn |= set_currentlight_value(&aqdata->lights[i], (packet[6] - RSSD_COLOR_LIGHT_OFFSET));
            break;
          }
          /*
          if (aqdata->lights[i].lightType != LC_DIMMER ) {
            set_currentlight_value(&aqdata->lights[i], (packet[6] - RSSD_COLOR_LIGHT_OFFSET));
          } else if (aqdata->lights[i].lightType == LC_DIMMER) {
            set_currentlight_value(&aqdata->lights[i], (packet[6] - RSSD_DIMMER_LIGHT_OFFSET) / 25);
          }*/
        }
      }


      if (packet[7] == RS_SA_AUX12) {
        LOG(RSSA_LOG,LOG_INFO,"AUX12 %d\n", packet[6]);
        rtn |= setLEDstate(aqdata->aqbuttons[13].led,  packet[6], aqdata);
        //_aqualink_data.aqbuttons[13].led->state = OFF;
      } else if (packet[7] == RS_SA_AUX13) {
        LOG(RSSA_LOG,LOG_INFO,"AUX13 %d\n", packet[6]);
        rtn |= setLEDstate(aqdata->aqbuttons[14].led,  packet[6], aqdata);
      } else if (packet[7] == RS_SA_AUX14) {
        LOG(RSSA_LOG,LOG_INFO,"AUX14 %d\n", packet[6]);
        rtn |= setLEDstate(aqdata->aqbuttons[15].led,  packet[6], aqdata);
      } else if (packet[7] == RS_SA_AUX15) {
        LOG(RSSA_LOG,LOG_INFO,"AUX15 %d\n", packet[6]);
        rtn |= setLEDstate(aqdata->aqbuttons[16].led,  packet[6], aqdata);
      }

      
    }
  }

  if (rtn){SET_DIRTY(aqdata->is_dirty);}

  return rtn;
}

/* Maybe use in future, not needed for moment 
   Idea here was to convert all button on/off commands to rs_serial_adapter commands to use if in all button probramming mode */
/*
unsigned char AllButton2RSsrialAdapter(unsigned char abcmd)
{
  switch(abcmd) {
    case KEY_PUMP:
      return RS_SA_PUMP;
    break;
    case KEY_SPA:
      return RS_SA_SPA;
    break;
    case KEY_AUX1:
      return RS_SA_AUX1;
    break;
    case KEY_AUX2:
      return RS_SA_AUX2;
    break;
    case KEY_AUX3:
      return RS_SA_AUX3;
    break;
    case KEY_AUX4:
      return RS_SA_AUX4;
    break;
    case KEY_AUX5:
      return RS_SA_AUX5;
    break;
    case KEY_AUX6:
      return RS_SA_AUX6;
    break;
    case KEY_AUX7:
      return RS_SA_AUX7;
    break;
    case KEY_POOL_HTR:
      return RS_SA_POOLHT;
    break;
    case KEY_SPA_HTR:
      return RS_SA_SPAHT;
    break;
  }
  return NUL;
}
*/

#ifdef DO_NOT_COMPILE


/
//*********************************************
// Notes on protocol for Serial Adapter.

/*
Message is reply ACK as below
--------- Send ACK  -----------
0x10|0x02|0x00|0x01|DeviceID|What|0xXX|0x10|0x03|
DeviceID = Below
What = 0x05 Query Value | 0x35 Set Value on next command.
--------- Reply Msg -------------
0x10|0x02|0x48|ReplyType|DeviceID|????|Value|0x00|0xXX|0x10|0x03|
ReplyType 0x13=status, 0x07=set value next message
DeviceID
???? Not sure 0x00 most of the time, 0x02 for (not set or vbat return)
Value  What it's set to, except VBAT. or 0x07 set on next command
--------- Send reply to above if 0x07 ---------
0x10|0x02|0x00|0x01|0x00|Value|0x4f|0x10|0x03|
Value to be set
--------- Send received from above ---------
0x10|0x02|0x48|ReplyType|DeviceID|????|Value|0x00|0xXX|0x10|0x03|
Same as previous reply.

*/
// Setpoints changes are in this group./
#define RS_SA_MODEL     0x00
#define RS_SA_OPTIONS   0x01
#define RS_SA_POOLSP    0x05  
#define RS_SA_POOLSP2   0x06  
#define RS_SA_SPASP     0x07  
#define RS_SA_POOLTMP   0x08
#define RS_SA_AIRTMP    0x09
#define RS_SA_UNITS     0x0a 
#define RS_SA_SPATMP    0x0b
#define RS_SA_SOLTMP    0x0c   
#define RS_SA_OPMODE    0x0d 
#define RS_SA_VBAT      0x0e  
#define RS_SA_WFALL     0x0f


/*
// Set & Query options
Query or Change simple on/off
--------- Send ACK --------------
0x10|0x02|0x00|0x01|What|DeviceID|0xXX|0x10|0x03|
What     - Byte 4 = What   (0x00 Query | 0x81 On | 0x80 off )
DeviceID - Byte 5 = (ID's below)

--------- Reply Msg -------------
In return
0x10|0x02|0x48|0x13   |0x02   |0x00   |0x0d|0x10|0x8c|0x10|0x03| 
0x10|0x02|0x48|MsgType|Status1|Status2|0x0e|DeviceID|0xXX|0x10|0x03|
MsgType  - Byte 3 = 0x13 (some state message)??
StatType - Byte 4 = 0x02 reply from setstate / 0x03 reply from getstatus (I THINK)
Status1  - Byte 5 = 0x00 0x01  (???)  if Byte4 is 0x02 then this is state 0x00=off 0x01=on /
Status2  - Byte 6 = 0x00 0x01   0x0e(option switch set can't change???)   if byte4 is 0x03, this this looks to be state
DeviceID - Byte 7 = Should match request.
*/
// These are duplicate for some above, so be careful
#define RS_SA_PUMP      0x0c  
#define RS_SA_PUMPLO    0x0d  
#define RS_SA_SPA       0x0e 
// Unique again
#define RS_SA_CLEANR    0x10    
#define RS_SA_POOLHT    0x11  
#define RS_SA_POOLHT2   0x12  
#define RS_SA_SPAHT     0x13 
#define RS_SA_SOLHT     0x14  
#define RS_SA_AUX1      0x15    
#define RS_SA_AUX2      0x16   
#define RS_SA_AUX3      0x17    
#define RS_SA_AUX4      0x18    
#define RS_SA_AUX5      0x19 
#define RS_SA_AUX6      0x1a
#define RS_SA_AUX7      0x1b
#define RS_SA_AUX8      0x1c
#define RS_SA_AUX9      0x1d
#define RS_SA_AUX10     0x1e
#define RS_SA_AUX11     0x1f

#define RS_SA_AUX12     0x20
#define RS_SA_AUX13     0x21
#define RS_SA_AUX14     0x22
#define RS_SA_AUX15     0x23



/*

#POOLSP=60
Jandy     To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x00|0x11|0x00|0x00|0x00|0x6d|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x05|0x35|0x4d|0x10|0x03|

Jandy     To 0x48 of type Unknown  | HEX: 0x10|0x02|0x48|0x07|0x05|0x66|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x3c|0x4f|0x10|0x03|

Jandy     To 0x48 of type Unknown  | HEX: 0x10|0x02|0x48|0x13|0x05|0x00|0x3c|0x00|0xae|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|


*/

/*
GET UNITS (SET TO F)
Debug:   RS Serial: Serial write 9 bytes
Debug:   RS Serial: To 0x00 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x0a|0x05|0x22|0x10|0x03|
Debug:   AqualinkD: To 0x48 of type Unknown  | HEX: 0x10|0x02|0x48|0x13|0x0a|0x00|0x00|0x00|0x77|0x10|0x03|
  Command 0x0a = |0x00|0x00|0x00  0|0|0

GET UNITS (SET TO C)
Debug:   RS Serial: Serial write 9 bytes
Debug:   RS Serial: To 0x00 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x0a|0x05|0x22|0x10|0x03|
Debug:   AqualinkD: To 0x48 of type Unknown  | HEX: 0x10|0x02|0x48|0x13|0x0a|0x00|0x01|0x00|0x78|0x10|0x03|
  Command 0x0a = |0x00|0x01|0x00  0|1|0

*/



/*


Debug:   AqualinkD: To 0x48 of type    Probe | HEX: 0x10|0x02|0x48|0x00|0x5a|0x10|0x03|

Debug:   RS Serial: Serial write 9 bytes
Debug:   RS Serial: To 0x00 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x05|0x18|0x10|0x03|
Debug:   AqualinkD: To 0x48 of type Unknown  | HEX: 0x10|0x02|0x48|0x13|0x00|0x1c|0x2f|0x00|0xb8|0x10|0x03|



Debug:   AqualinkD: To 0x48 of type    Probe | HEX: 0x10|0x02|0x48|0x00|0x5a|0x10|0x03|
Debug:   AqualinkD: To 0x00 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x05|0x18|0x10|0x03|

Debug:   AqualinkD: To 0x48 of type Unknown  | HEX: 0x10|0x02|0x48|0x13|0x00|0x19|0x79|0x01|0x00|0x10|0x03|
Debug:   AqualinkD: To 0x00 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|

Debug:   AqualinkD: To 0x48 of type Unknown  | HEX: 0x10|0x02|0x48|0x13|0x00|0x19|0x79|0x01|0x00|0x10|0x03|
Debug:   AqualinkD: To 0x00 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|




Startup.

Jandy     To 0x48 of type    Probe | HEX: 0x10|0x02|0x48|0x00|0x5a|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x05|0x18|0x10|0x03|

Jandy     To 0x48 of type Unknown  | HEX: 0x10|0x02|0x48|0x13|0x00|0x19|0x78|0x00|0xfe|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|

Jandy     To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x10|0x01|0x00|0x00|0x00|0x6d|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x0f|0x35|0x57|0x10|0x03|

Jandy     To 0x48 of type Unknown  | HEX: 0x10|0x02|0x48|0x07|0x0f|0x70|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x01|0x14|0x10|0x03|

Jandy     To 0x48 of type Unknown  | HEX: 0x10|0x02|0x48|0x13|0x0f|0x00|0x00|0x00|0x7c|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|

Jandy     To 0x60 of type    Probe | HEX: 0x10|0x02|0x60|0x00|0x72|0x10|0x03|

Jandy     To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x10|0x01|0x00|0x00|0x00|0x6d|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|

Jandy     To 0x51 of type    Probe | HEX: 0x10|0x02|0x51|0x00|0x63|0x10|0x03|

Jandy     To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x10|0x01|0x00|0x00|0x00|0x6d|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|

Jandy     To 0x60 of type    Probe | HEX: 0x10|0x02|0x60|0x00|0x72|0x10|0x03|

Jandy     To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x10|0x01|0x00|0x00|0x00|0x6d|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|

Jandy     To 0x52 of type    Probe | HEX: 0x10|0x02|0x52|0x00|0x64|0x10|0x03|

Jandy     To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x10|0x01|0x00|0x00|0x00|0x6d|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|

Jandy     To 0x60 of type    Probe | HEX: 0x10|0x02|0x60|0x00|0x72|0x10|0x03|

Jandy     To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x10|0x01|0x00|0x00|0x00|0x6d|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|

Jandy     To 0x53 of type    Probe | HEX: 0x10|0x02|0x53|0x00|0x65|0x10|0x03|

Jandy     To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x10|0x01|0x00|0x00|0x00|0x6d|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|

Jandy     To 0x60 of type    Probe | HEX: 0x10|0x02|0x60|0x00|0x72|0x10|0x03|

Jandy     To 0x80 of type    Probe | HEX: 0x10|0x02|0x80|0x00|0x92|0x10|0x03|

Jandy     To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x10|0x01|0x00|0x00|0x00|0x6d|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|

Jandy     To 0x58 of type    Probe | HEX: 0x10|0x02|0x58|0x00|0x6a|0x10|0x03|

Jandy     To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x10|0x01|0x00|0x00|0x00|0x6d|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|

Jandy     To 0x58 of type    Probe | HEX: 0x10|0x02|0x58|0x00|0x6a|0x10|0x03|

Jandy     To 0x60 of type    Probe | HEX: 0x10|0x02|0x60|0x00|0x72|0x10|0x03|

Jandy     To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x10|0x01|0x00|0x00|0x00|0x6d|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|

Jandy     To 0x58 of type  Message | HEX: 0x10|0x02|0x58|0x03|0x01|0x52|0x45|0x56|0x20|0x54|0x2e|0x30|0x2e|0x31|0x00|0x61|0x74|0x00|0x38|0x33|0x00|0xcc|0x10|0x03|  Message : REV T.0.1at83

Jandy     To 0x68 of type    Probe | HEX: 0x10|0x02|0x68|0x00|0x7a|0x10|0x03|

Jandy     To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x10|0x01|0x00|0x00|0x00|0x6d|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|

Jandy     To 0x58 of type    Probe | HEX: 0x10|0x02|0x58|0x00|0x6a|0x10|0x03|

Jandy     To 0x69 of type    Probe | HEX: 0x10|0x02|0x69|0x00|0x7b|0x10|0x03|

Jandy     To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x10|0x01|0x00|0x00|0x00|0x6d|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|

Jandy     To 0x58 of type  Message | HEX: 0x10|0x02|0x58|0x03|0x02|0x52|0x53|0x2d|0x38|0x20|0x43|0x6f|0x6d|0x62|0x6f|0x00|0x74|0x00|0x38|0x33|0x00|0x68|0x10|0x03|  Message : RS-8 Combot83

Jandy     To 0x6a of type    Probe | HEX: 0x10|0x02|0x6a|0x00|0x7c|0x10|0x03|

Jandy     To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x10|0x01|0x00|0x00|0x00|0x6d|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|

Jandy     To 0x58 of type    Probe | HEX: 0x10|0x02|0x58|0x00|0x6a|0x10|0x03|

Jandy     To 0x6b of type    Probe | HEX: 0x10|0x02|0x6b|0x00|0x7d|0x10|0x03|

Jandy     To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x10|0x01|0x00|0x00|0x00|0x6d|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|

Jandy     To 0x58 of type    Probe | HEX: 0x10|0x02|0x58|0x00|0x6a|0x10|0x03|

Jandy     To 0x70 of type    Probe | HEX: 0x10|0x02|0x70|0x00|0x82|0x10|0x03|

Jandy     To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x10|0x01|0x00|0x00|0x00|0x6d|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|

Jandy     To 0x81 of type    Probe | HEX: 0x10|0x02|0x81|0x00|0x93|0x10|0x03|

Jandy     To 0x58 of type    Probe | HEX: 0x10|0x02|0x58|0x00|0x6a|0x10|0x03|

Jandy     To 0x71 of type    Probe | HEX: 0x10|0x02|0x71|0x00|0x83|0x10|0x03|

Jandy     To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x10|0x01|0x00|0x00|0x00|0x6d|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|

Jandy     To 0x58 of type    Probe | HEX: 0x10|0x02|0x58|0x00|0x6a|0x10|0x03|

Jandy     To 0x72 of type    Probe | HEX: 0x10|0x02|0x72|0x00|0x84|0x10|0x03|

Jandy     To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x10|0x01|0x00|0x00|0x00|0x6d|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|

Jandy     To 0x58 of type    Probe | HEX: 0x10|0x02|0x58|0x00|0x6a|0x10|0x03|

Jandy     To 0x73 of type    Probe | HEX: 0x10|0x02|0x73|0x00|0x85|0x10|0x03|

Jandy     To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x10|0x01|0x00|0x00|0x00|0x6d|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|

Jandy     To 0x58 of type    Probe | HEX: 0x10|0x02|0x58|0x00|0x6a|0x10|0x03|

Jandy     To 0x88 of type    Probe | HEX: 0x10|0x02|0x88|0x00|0x9a|0x10|0x03|

Jandy     To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x10|0x01|0x00|0x00|0x00|0x6d|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x08|0x05|0x20|0x10|0x03|

Jandy     To 0x48 of type Unknown  | HEX: 0x10|0x02|0x48|0x13|0x08|0x02|0x00|0x00|0x77|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|

Jandy     To 0x58 of type    Probe | HEX: 0x10|0x02|0x58|0x00|0x6a|0x10|0x03|

Jandy     To 0x89 of type    Probe | HEX: 0x10|0x02|0x89|0x00|0x9b|0x10|0x03|

Jandy     To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x10|0x01|0x00|0x00|0x00|0x6d|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|

Jandy     To 0x60 of type    Probe | HEX: 0x10|0x02|0x60|0x00|0x72|0x10|0x03|

Jandy     To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x10|0x01|0x00|0x00|0x00|0x6d|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|

Jandy     To 0x08 of type    Probe | HEX: 0x10|0x02|0x08|0x00|0x1a|0x10|0x03|

Jandy     To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x10|0x01|0x00|0x00|0x00|0x6d|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|

Jandy     To 0x60 of type    Probe | HEX: 0x10|0x02|0x60|0x00|0x72|0x10|0x03|

Jandy     To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x10|0x01|0x00|0x00|0x00|0x6d|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|

Jandy     To 0x80 of type    Probe | HEX: 0x10|0x02|0x80|0x00|0x92|0x10|0x03|

Jandy     To 0x09 of type    Probe | HEX: 0x10|0x02|0x09|0x00|0x1b|0x10|0x03|

Jandy     To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x10|0x01|0x00|0x00|0x00|0x6d|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|

Jandy     To 0x60 of type    Probe | HEX: 0x10|0x02|0x60|0x00|0x72|0x10|0x03|

Jandy     To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x10|0x01|0x00|0x00|0x00|0x6d|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|

Jandy     To 0x0a of type    Probe | HEX: 0x10|0x02|0x0a|0x00|0x1c|0x10|0x03|

Jandy     To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x10|0x01|0x00|0x00|0x00|0x6d|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|

Jandy     To 0x60 of type    Probe | HEX: 0x10|0x02|0x60|0x00|0x72|0x10|0x03|

Jandy     To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x10|0x01|0x00|0x00|0x00|0x6d|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|

Jandy     To 0x0b of type    Probe | HEX: 0x10|0x02|0x0b|0x00|0x1d|0x10|0x03|

Jandy     To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x10|0x01|0x00|0x00|0x00|0x6d|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|

Jandy     To 0x60 of type    Probe | HEX: 0x10|0x02|0x60|0x00|0x72|0x10|0x03|

Jandy     To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x10|0x01|0x00|0x00|0x00|0x6d|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|

Jandy     To 0x40 of type    Probe | HEX: 0x10|0x02|0x40|0x00|0x52|0x10|0x03|

Jandy     To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x10|0x01|0x00|0x00|0x00|0x6d|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|

Jandy     To 0x60 of type    Probe | HEX: 0x10|0x02|0x60|0x00|0x72|0x10|0x03|

Jandy     To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x10|0x01|0x00|0x00|0x00|0x6d|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|

Jandy     To 0x41 of type    Probe | HEX: 0x10|0x02|0x41|0x00|0x53|0x10|0x03|

Jandy     To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x10|0x01|0x00|0x00|0x00|0x6d|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|

Jandy     To 0x60 of type    Probe | HEX: 0x10|0x02|0x60|0x00|0x72|0x10|0x03|

Jandy     To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x10|0x01|0x00|0x00|0x00|0x6d|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|


*/

/*


#POOLSP?
byte 4 is command 0x05
byte 5 is query or set (0x05 query, 0x35 set)
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x05|0x05|0x1d|0x10|0x03|
Jandy     To 0x48 of type Unknown  | HEX: 0x10|0x02|0x48|0x13|0x05|0x00|0x53|0x00|0xc5|0x10|0x03|
!00 POOLSP = 83 F
byte 4 is return command
byte 6 is 83 = 0x53


#POOLSP=45
Jandy     To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x00|0x00|0x00|0x00|0x00|0x5c|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x05|0x35|0x4d|0x10|0x03|

Jandy     To 0x48 of type Unknown  | HEX: 0x10|0x02|0x48|0x07|0x05|0x66|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x2d|0x40|0x10|0x03|

Jandy     To 0x48 of type Unknown  | HEX: 0x10|0x02|0x48|0x13|0x05|0x00|0x2d|0x00|0x9f|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|
!00 POOLSP=45

#POOLTMP?
byte 4 is command 0x08
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x08|0x05|0x20|0x10|0x03|
Jandy     To 0x48 of type Unknown  | HEX: 0x10|0x02|0x48|0x13|0x08|0x00|0x41|0x00|0xb6|0x10|0x03|
!00 POOLTMP = 65 F


Debug:   AqualinkD: To 0x00 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x08|0x05|0x20|0x10|0x03|
Debug:   AqualinkD: To 0x48 of type Unknown  | HEX: 0x10|0x02|0x48|0x13|0x08|0x00|0x41|0x00|0xb6|0x10|0x03|


#UNITS?
Debug:   AqualinkD: To 0x00 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x0a|0x05|0x22|0x10|0x03|
Debug:   AqualinkD: To 0x48 of type Unknown  | HEX: 0x10|0x02|0x48|0x13|0x0a|0x00|0x00|0x00|0x77|0x10|0x03|
!00 UNITS = F

#SPASP?
Debug:   AqualinkD: To 0x00 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x07|0x05|0x1f|0x10|0x03|
Debug:   AqualinkD: To 0x48 of type Unknown  | HEX: 0x10|0x02|0x48|0x13|0x07|0x00|0x66|0x00|0xda|0x10|0x03|



#MODEL?
Jandy   From 0x48 of type              Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x05|0x18|0x10|0x03|
Jandy     To 0x48 of type   RSSA DevStatus | HEX: 0x10|0x02|0x48|0x13|0x00|0x19|0x79|0x00|0xff|0x10|0x03|     // 25 121
!00 MODEL = 6521    -RS 6 Combo

Jandy     To 0x48 of type   RSSA DevStatus | HEX: 0x10|0x02|0x48|0x13|0x00|0x19|0x78|0x00|0xfe|0x10|0x03|     // 25 120
!00 MODEL = 6520    -RS 8 Combo

Jandy     To 0x48 of type   RSSA DevStatus | HEX: 0x10|0x02|0x48|0x13|0x00|0x19|0x7a|0x00|0x00|0x10|0x03|     // 25 122
!00 MODEL = 6522    - RS 4 Combo

Jandy     To 0x48 of type   RSSA DevStatus | HEX: 0x10|0x02|0x48|0x13|0x00|0x19|0x7b|0x00|0x01|0x10|0x03|     // 25 123
!00 MODEL = 6523    - RS 8  Only

Jandy     To 0x48 of type   RSSA DevStatus | HEX: 0x10|0x02|0x48|0x13|0x00|0x19|0x7c|0x00|0x02|0x10|0x03|     // 25 124
!00 MODEL = 6524    - RS 6 only

Jandy     To 0x48 of type   RSSA DevStatus | HEX: 0x10|0x02|0x48|0x13|0x00|0x19|0x7d|0x00|0x03|0x10|0x03|     // 25 125
!00 MODEL = 6525   - RS 4 only

Jandy     To 0x48 of type   RSSA DevStatus | HEX: 0x10|0x02|0x48|0x13|0x00|0x19|0x7e|0x01|0x05|0x10|0x03|     // 25 126     1
!00 MODEL = 6526   - dual 6/2

Jandy     To 0x48 of type   RSSA DevStatus | HEX: 0x10|0x02|0x48|0x13|0x00|0x1c|0x21|0x00|0xaa|0x10|0x03|     // 28 33
!00 MODEL = 7201   - 12 Combo

Jandy     To 0x48 of type   RSSA DevStatus | HEX: 0x10|0x02|0x48|0x13|0x00|0x1c|0x22|0x00|0xab|0x10|0x03|     // 28 34
!00 MODEL = 7202   -  16 combo

Jandy     To 0x48 of type   RSSA DevStatus | HEX: 0x10|0x02|0x48|0x13|0x00|0x1c|0x2e|0x00|0xb7|0x10|0x03|     // 28 46
!00 MODEL = 7214   -  12 only

Jandy     To 0x48 of type   RSSA DevStatus | HEX: 0x10|0x02|0x48|0x13|0x00|0x1c|0x2f|0x00|0xb8|0x10|0x03|     // 28 47
!00 MODEL = 7215   - 16 only

Jandy     To 0x48 of type   RSSA DevStatus | HEX: 0x10|0x02|0x48|0x13|0x00|0x1c|0x30|0x01|0xba|0x10|0x03|     // 28 30   1
!00 MODEL = 7216   - dual 2/10

Jandy     To 0x48 of type   RSSA DevStatus | HEX: 0x10|0x02|0x48|0x13|0x00|0x1c|0x31|0x01|0xbb|0x10|0x03|     // 28 49   1
!00 MODEL = 7217  - dual 2/14

Jandy     To 0x48 of type   RSSA DevStatus | HEX: 0x10|0x02|0x48|0x13|0x00|0x19|0x88|0x00|0x0e|0x10|0x03|     // 25 136
!00 MODEL = 6536  - PD8 Combo

Jandy     To 0x48 of type   RSSA DevStatus | HEX: 0x10|0x02|0x48|0x13|0x00|0x19|0x89|0x00|0x0f|0x10|0x03|     // 25 137
!00 MODEL = 6537  - PD8 only

#OPMODE?
Jandy   From 0x48 of type              Ack | HEX: 0x10|0x02|0x00|0x01|0x0d|0x05|0x25|0x10|0x03|
(One of 3 replys)
Jandy     To 0x48 of type   RSSA DevStatus | HEX: 0x10|0x02|0x48|0x13|0x0d|0x00|0x00|0x00|0x7a|0x10|0x03|
!00 OPMODE = AUTO
Jandy     To 0x48 of type   RSSA DevStatus | HEX: 0x10|0x02|0x48|0x13|0x0d|0x00|0x01|0x00|0x7b|0x10|0x03|
!00 OPMODE = SERVICE
Jandy     To 0x48 of type   RSSA DevStatus | HEX: 0x10|0x02|0x48|0x13|0x0d|0x00|0x02|0x00|0x7c|0x10|0x03|
!00 OPMODE = TIMEOUT

#OPTIONS?
Jandy   From 0x48 of type              Ack | HEX: 0x10|0x02|0x00|0x01|0x01|0x05|0x19|0x10|0x03|
Jandy     To 0x48 of type   RSSA DevStatus | HEX: 0x10|0x02|0x48|0x13|0x01|0x00|0x00|0x00|0x6e|0x10|0x03|
!00 OPTIONS = 0


#SPASP=101
SPA|SET  = 0x07|0x35
Debug:   AqualinkD: To 0x00 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x07|0x35|0x4f|0x10|0x03|
Debug:   AqualinkD: To 0x48 of type Unknown  | HEX: 0x10|0x02|0x48|0x07|0x07|0x68|0x10|0x03|
(second part)
100 = 0x64
Debug:   AqualinkD: To 0x00 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x64|0x77|0x10|0x03|
Debug:   AqualinkD: To 0x48 of type Unknown  | HEX: 0x10|0x02|0x48|0x13|0x07|0x00|0x65|0x00|0xd9|0x10|0x03|

#SPASP=102
Debug:   AqualinkD: To 0x00 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x07|0x35|0x4f|0x10|0x03|
Debug:   AqualinkD: To 0x48 of type Unknown  | HEX: 0x10|0x02|0x48|0x07|0x07|0x68|0x10|0x03|
(second part)
Debug:   AqualinkD: To 0x00 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x78|0x8b|0x10|0x03|
Debug:   AqualinkD: To 0x48 of type Unknown  | HEX: 0x10|0x02|0x48|0x13|0x07|0x00|0x62|0x00|0xd6|0x10|0x03|

#SPASP=90
Debug:   AqualinkD: To 0x00 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x07|0x35|0x4f|0x10|0x03|
Debug:   AqualinkD: To 0x48 of type Unknown  | HEX: 0x10|0x02|0x48|0x07|0x07|0x68|0x10|0x03|
(second part)
Debug:   AqualinkD: To 0x00 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x5a|0x6d|0x10|0x03|
Debug:   AqualinkD: To 0x48 of type Unknown  | HEX: 0x10|0x02|0x48|0x13|0x07|0x00|0x61|0x00|0xd5|0x10|0x03|

#POOLSP=97
Debug:   AqualinkD: To 0x00 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x05|0x35|0x4d|0x10|0x03|
Debug:   AqualinkD: To 0x48 of type Unknown  | HEX: 0x10|0x02|0x48|0x07|0x05|0x66|0x10|0x03|
(second)
Debug:   AqualinkD: To 0x00 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x61|0x74|0x10|0x03|
Debug:   AqualinkD: To 0x48 of type Unknown  | HEX: 0x10|0x02|0x48|0x13|0x05|0x00|0x4f|0x00|0xc1|0x10|0x03|

#VBAT?
Debug:   AqualinkD: To 0x00 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x0e|0x05|0x26|0x10|0x03|
Debug:   AqualinkD: To 0x48 of type Unknown  | HEX: 0x10|0x02|0x48|0x13|0x0e|0x02|0x67|0x00|0xe4|0x10|0x03|
!00 VBAT = 900






#POOLSP+
?08 SETPT OPERATION FAILED
Debug:   AqualinkD: To 0x00 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x05|0x35|0x4d|0x10|0x03|
Debug:   AqualinkD: To 0x48 of type Unknown  | HEX: 0x10|0x02|0x48|0x07|0x05|0x66|0x10|0x03|
Debug:   AqualinkD: To 0x00 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x80|0x00|0x93|0x10|0x03|
Debug:   AqualinkD: To 0x48 of type Unknown  | HEX: 0x10|0x02|0x48|0x13|0x02|0x00|0x10|0x00|0x7f|0x10|0x03|

#POOLSP+
?08 SETPT OPERATION FAILED
Debug:   AqualinkD: To 0x00 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x05|0x35|0x4d|0x10|0x03|
Debug:   AqualinkD: To 0x48 of type Unknown  | HEX: 0x10|0x02|0x48|0x07|0x05|0x66|0x10|0x03|
Debug:   AqualinkD: To 0x00 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x80|0x00|0x93|0x10|0x03|
Debug:   AqualinkD: To 0x48 of type Unknown  | HEX: 0x10|0x02|0x48|0x13|0x02|0x00|0x10|0x00|0x7f|0x10|0x03|

#POOLSP+
?08 SETPT OPERATION FAILED
Debug:   AqualinkD: To 0x00 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x05|0x35|0x4d|0x10|0x03|
Debug:   AqualinkD: To 0x48 of type Unknown  | HEX: 0x10|0x02|0x48|0x07|0x05|0x66|0x10|0x03|
Debug:   AqualinkD: To 0x00 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x80|0x00|0x93|0x10|0x03|
Debug:   AqualinkD: To 0x48 of type Unknown  | HEX: 0x10|0x02|0x48|0x13|0x02|0x00|0x10|0x00|0x7f|0x10|0x03|

#POOLSP-
!00 POOLSP = 64 F
Debug:   AqualinkD: To 0x00 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x40|0x00|0x53|0x10|0x03|
Debug:   AqualinkD: To 0x48 of type Unknown  | HEX: 0x10|0x02|0x48|0x13|0x05|0x00|0x40|0x00|0xb2|0x10|0x03|
Debug:   AqualinkD: To 0x31 of type    Probe | HEX: 0x10|0x02|0x31|0x00|0x43|0x10|0x03|
Debug:   AqualinkD: To 0x48 of type Unknown  | HEX: 0x10|0x02|0x48|0x13|0x05|0x00|0x40|0x00|0xb2|0x10|0x03|


Debug:   AqualinkD: To 0x00 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x05|0x35|0x4d|0x10|0x03|
Debug:   AqualinkD: To 0x48 of type Unknown  | HEX: 0x10|0x02|0x48|0x07|0x05|0x66|0x10|0x03|
Debug:   AqualinkD: To 0x00 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x40|0x00|0x53|0x10|0x03|
Debug:   AqualinkD: To 0x48 of type Unknown  | HEX: 0x10|0x02|0x48|0x13|0x05|0x00|0x40|0x00|0xb2|0x10|0x03|


#AUX5=on
Debug:   AqualinkD: To 0x00 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x81|0x19|0xad|0x10|0x03|
Debug:   AqualinkD: To 0x48 of type Unknown  | HEX: 0x10|0x02|0x48|0x13|0x02|0x01|0x00|0x19|0x89|0x10|0x03|
  Command 0x02 = |0x01|0x00|0x19  1|0|25

#AUX5=off
Debug:   AqualinkD: To 0x00 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x80|0x19|0xac|0x10|0x03|
Debug:   AqualinkD: To 0x48 of type Unknown  | HEX: 0x10|0x02|0x48|0x13|0x02|0x00|0x00|0x19|0x88|0x10|0x03|
  Command 0x02 = |0x00|0x00|0x19  0|0|25


#AUX4 = 1 100%
Jandy   From 0x48 of type              Ack | HEX: 0x10|0x02|0x00|0x01|0xcc|0x18|0xf7|0x10|0x03|
Jandy     To 0x48 of type   RSSA Cmd Error | HEX: 0x10|0x02|0x48|0x13|0x02|0x00|0x0c|0x18|0x93|0x10|0x03|
?21 AUX NOT ASSIGNED

#AUX3 = 1 75%
Jandy   From 0x48 of type              Ack | HEX: 0x10|0x02|0x00|0x01|0xaf|0x17|0xd9|0x10|0x03|
Jandy     To 0x48 of type   RSSA Cmd Error | HEX: 0x10|0x02|0x48|0x13|0x02|0x00|0x0c|0x17|0x92|0x10|0x03|
?21 AUX NOT ASSIGNED

#AUX3 = 1 50%
Jandy   From 0x48 of type              Ack | HEX: 0x10|0x02|0x00|0x01|0x96|0x17|0xc0|0x10|0x03|
Jandy     To 0x48 of type   RSSA Cmd Error | HEX: 0x10|0x02|0x48|0x13|0x02|0x00|0x0c|0x17|0x92|0x10|0x03|
?21 AUX NOT ASSIGNED

#AUX3 = 1 25%
Jandy   From 0x48 of type              Ack | HEX: 0x10|0x02|0x00|0x01|0xfd|0x17|0x27|0x10|0x03|
Jandy     To 0x48 of type   RSSA Cmd Error | HEX: 0x10|0x02|0x48|0x13|0x02|0x00|0x0c|0x17|0x92|0x10|0x03|
?21 AUX NOT ASSIGNED

*/


/*
Return for all
Byte | Description
3    | 0x13 = Some Status
4    | 
5    |
6    |
7    | ID of device/setting

Query or Change simple on/off
Byte 4 What   (0x00 Query | 0x81 On | 0x80 off )
Byte 5 Device (pict from List)

In return
Byte 3 = 0x13 (some state message)??
Byye 4 = 0x02 or 0x03 (not sure meaning)
Byte 5 = 0x00 0x01  (???)  if Byte4 is 0x02 then this is state 0x00=off 0x01=on /
Byte 6 = 0x00 0x01   0x0e(option switch set can't change???)   if byte4 is 0x03, this this looks to be state
Byte 7 = DeviceID.  Should match request.


#AUX1?     0x10|0x02|0x00|0x01|0x00|0x15|0x28|0x10|0x03|     Return 0x10|0x02|0x48|0x13|0x03|0x00|0x00|0x15|0x85|0x10|0x03|
#AUX1=on   0x10|0x02|0x00|0x01|0x81|0x15|0xa9|0x10|0x03|     Return 0x10|0x02|0x48|0x13|0x02|0x01|0x00|0x15|0x85|0x10|0x03|
#AUX1=off  0x10|0x02|0x00|0x01|0x80|0x15|0xa8|0x10|0x03|     Return 0x10|0x02|0x48|0x13|0x02|0x00|0x00|0x15|0x84|0x10|0x03|

#AUX1?  When OPTION SWITCH IS SET (something to do with cleaner mode)
#AUX1?     0x10|0x02|0x00|0x01|0x00|0x15|0x28|0x10|0x03|       HEX: 0x10|0x02|0x48|0x13|0x02|0x00|0x0e|0x15|0x92|0x10|0x03|
#AUX2?  Normal
#AUX2?     0x10|0x02|0x00|0x01|0x00|0x16|0x29|0x10|0x03|     | HEX: 0x10|0x02|0x48|0x13|0x03|0x00|0x00|0x16|0x86|0x10|0x03|
#AUX2=on   0x10|0x02|0x00|0x01|0x81|0x16|0xaa|0x10|0x03|            0x10|0x02|0x48|0x13|0x02|0x01|0x00|0x16|0x86|0x10|0x03|
#AUX2? (when on)                                                    0x10|0x02|0x48|0x13|0x03|0x00|0x01|0x16|0x87|0x10|0x03|
#AUX2=off  0x10|0x02|0x00|0x01|0x80|0x16|0xa9|0x10|0x03|       HEX: 0x10|0x02|0x48|0x13|0x02|0x00|0x00|0x16|0x85|0x10|0x03|
(when already off)
#AUX2=off  0x10|0x02|0x00|0x01|0x80|0x16|0xa9|0x10|0x03|       HEX: 0x10|0x02|0x48|0x13|0x02|0x00|0x00|0x16|0x85|0x10|0x03|
#POOLSP=45
Jandy      0x10|0x02|0x00|0x01|0x05|0x35|0x4d|0x10|0x03|
Jandy    return HEX: 0x10|0x02|0x48|0x07|0x05|0x66|0x10|0x03|
Jandy      0x10|0x02|0x00|0x01|0x00|0x2d|0x40|0x10|0x03|

*/





/*
// Query only options, work as below.
Byte 4 Device ID
Byte 5 (0x05) Looks to be fixed
// Return
Byte 4 Device ID (should match request)
Byte 5 0x00 some OK ./ 
Byte 6 value

// More Complex examples, 2 messages when setting a value
// first request
Byte 4 = DeviceID
Byte 4 = 0x35   (I want to change something????)
// first reply
Byte 3 = 0x07
Byte 4 = DeviceID

// Second request
Byte 4 = 0x00
Byte 6 = value
// Second reply
Byte 3 = 0x13
Byte 4 = DeviceID
Byte 5 = 0x00 (??????)
Byte 6 = (Value)
*/






/*
// Query only options.
Byte 4 Device ID
Byte 5 (0x05) Looks to be fixed
// Return
Byte 4 Device ID (should match request)
Byte 5 0x00 some OK ./ 
Byte 6 value
*/
/*

#AIRTMP    0x09   0x10|0x02|0x00|0x01|0x09|0x05|0x21|0x10|0x03|   94 F                            | HEX: 0x10|0x02|0x48|0x13|0x09|0x00|0x5e|0x00|0xd4|0x10|0x03|   
#POOLTMP   0x08   0x10|0x02|0x00|0x01|0x08|0x05|0x20|0x10|0x03|                                     85 F 0x10|0x02|0x48|0x13|0x08|0x00|0x55|0x00|0xca|0x10|0x03|
#SPATMP    0x0b   0x10|0x02|0x00|0x01|0x0b|0x05|0x23|0x10|0x03|   //?18 SPA TEMP VALUE IS UNAVAILABLE =  0x10|0x02|0x48|0x13|0x0b|0x02|0x00|0x00|0x7a|0x10|0x03|
#SOLTMP    0x0c   0x10|0x02|0x00|0x01|0x0c|0x05|0x24|0x10|0x03|   //  !00 SOLTMP = 60 F =                0x10|0x02|0x48|0x13|0x0c|0x00|0x3c|0x00|0xb5|0x10|0x03|
#OPMODE    0x0d   0x10|0x02|0x00|0x01|0x0d|0x05|0x25|0x10|0x03|   !00 OPMODE = AUTO                      0x10|0x02|0x48|0x13|0x0d|0x00|0x00|0x00|0x7a|0x10|0x03|
#OPTIONS   0x01   0x10|0x02|0x00|0x01|0x01|0x05|0x19|0x10|0x03|   00 OPTIONS = 1                         0x10|0x02|0x48|0x13|0x01|0x00|0x01|0x00|0x6f|0x10|0x03|
#UNITS     0x0a   0x10|0x02|0x00|0x01|0x0a|0x05|0x22|0x10|0x03|   //  !00 UNITS = F                      0x10|0x02|0x48|0x13|0x0a|0x00|0x00|0x00|0x77|0x10|0x03|
#VBAT      0x0e   0x10|0x02|0x00|0x01|0x0e|0x05|0x26|0x10|0x03|   // !00 VBAT = 900                      0x10|0x02|0x48|0x13|0x0e|0x02|0x67|0x00|0xe4|0x10|0x03|

#AUX1    0x15    0x10|0x02|0x00|0x01|0x00|0x15|0x28|0x10|0x03|    OPTION SWITCH IS SET  0x10|0x02|0x48|0x13|0x02|0x00|0x0e|0x15|0x92|0x10|0x03|
#AUX2    0x16    0x10|0x02|0x00|0x01|0x00|0x16|0x29|0x10|0x03|                          0x10|0x02|0x48|0x13|0x03|0x00|0x00|0x16|0x86|0x10|0x03|
#AUX3    0x17    0x10|0x02|0x00|0x01|0x00|0x17|0x2a|0x10|0x03|                          0x10|0x02|0x48|0x13|0x03|0x00|0x00|0x17|0x87|0x10|0x03|
#AUX4    0x18    0x10|0x02|0x00|0x01|0x00|0x18|0x2b|0x10|0x03|    AUX4 = 0              0x10|0x02|0x48|0x13|0x03|0x00|0x00|0x18|0x88|0x10|0x03|
#AUX5    0x19    0x10|0x02|0x00|0x01|0x00|0x19|0x2c|0x10|0x03|     AUX5 = 0             0x10|0x02|0x48|0x13|0x03|0x00|0x00|0x19|0x89|0x10|0x03|
#AUX6    0x1a
#AUX7    0x1b
#AUX8    0x1c
#AUX9    0x1d
#AUX10   0x1e
#AUX11   0x1f
#AUX12   0x20
#AUX13   0x21
#AUX14   0x22
#AUX15   0x23
#CLEANR  0x10    0x10|0x02|0x00|0x01|0x00|0x10|0x23|0x10|0x03|  ?23 OPTION SWITCH NOT SET   0x10|0x02|0x48|0x13|0x02|0x00|0x0d|0x10|0x8c|0x10|0x03|  
#CMDCHR 
#DIAG 
#ECHO 
#ERRCHR 
#LEDS 
#MODEL     0x00  0x10|0x02|0x00|0x01|0x00|0x05|0x18|0x10|0x03|   6521     0x10|0x02|0x48|0x13|0x00|0x19|0x79|0x01|0x00|0x10|0x03|
#NRMCHR 

#POOLHT    0x11  0x10|0x02|0x00|0x01|0x00|0x11|0x24|0x10|0x03|    / Byte 5 ?????
#POOLHT2   0x12  0x10|0x02|0x00|0x01|0x00|0x12|0x25|0x10|0x03|       0x10|0x02|0x48|0x13|0x03|0x00|0x00|0x12|0x82|0x10|0x03|
#SOLHT     0x14  0x10|0x02|0x00|0x01|0x00|0x14|0x27|0x10|0x03|
#SPAHT     0x13  0x10|0x02|0x00|0x01|0x00|0x13|0x26|0x10|0x03|

#SPA       0x0e   0x10|0x02|0x00|0x01|0x00|0x0e|0x21|0x10|0x03|   SPA=0   0x10|0x02|0x48|0x13|0x03|0x00|0x00|0x0e|0x7e|0x10|0x03|
#SPA=1            0x10|0x02|0x00|0x01|0x81|0x0e|0xa2|0x10|0x03|  SPA=1    0x10|0x02|0x48|0x13|0x02|0x01|0x00|0x0e|0x7e|0x10|0x03|
#SPA=0            0x10|0x02|0x00|0x01|0x80|0x0e|0xa1|0x10|0x03|  SPA=0    0x10|0x02|0x48|0x13|0x02|0x00|0x00|0x0e|0x7d|0x10|0x03|

#WFALL     0x0f  0x10|0x02|0x00|0x01|0x00|0x0f|0x22|0x10|0x03|   // ?23 OPTION SWITCH NOT SET           0x10|0x02|0x48|0x13|0x02|0x00|0x0d|0x0f|0x8b|0x10|0x03|

// More Complex examples, 2 messages when setting a value
// first request
Byte 4 = DeviceID
Byte 4 = 0x35   (I want to change something????)
// first reply
Byte 3 = 0x07
Byte 4 = DeviceID

// Second request
Byte 4 = 0x00
Byte 6 = value
// Second reply
Byte 3 = 0x13
Byte 4 = DeviceID
Byte 5 = 0x00 (??????)
Byte 6 = (Value)

#POOLSP    0x05  0x10|0x02|0x00|0x01|0x05|0x05|0x1d|0x10|0x03|     60 F 0x10|0x02|0x48|0x13|0x05|0x00|0x3c|0x00|0xae|0x10|0x03|
#POOLSP=60       0x10|0x02|0x00|0x01|0x05|0x35|0x4d|0x10|0x03|          0x10|0x02|0x48|0x07|0x05|0x66|0x10|0x03|
(Second messsage)0x10|0x02|0x00|0x01|0x00|0x3c|0x4f|0x10|0x03|     60 F 0x10|0x02|0x48|0x13|0x05|0x00|0x3c|0x00|0xae|0x10|0x03|

#POOLSP2?  0x06  0x10|0x02|0x00|0x01|0x06|0x05|0x1e|0x10|0x03|     60 f 0x10|0x02|0x48|0x13|0x06|0x00|0x3c|0x00|0xaf|0x10|0x03|
#POOLSP2=70      0x10|0x02|0x00|0x01|0x06|0x35|0x4e|0x10|0x03|     60 f 0x10|0x02|0x48|0x13|0x06|0x00|0x3c|0x00|0xaf|0x10|0x03|

#SPASP     0x07  0x10|0x02|0x00|0x01|0x07|0x05|0x1f|0x10|0x03|   102 F  = 0x10|0x02|0x48|0x13|0x07|0x00|0x66|0x00|0xda|0x10|0x03|
#SPASP=99        0x10|0x02|0x00|0x01|0x07|0x35|0x4f|0x10|0x03|          = 0x10|0x02|0x48|0x07|0x07|0x68|0x10|0x03|
(Second messsage)0x10|0x02|0x00|0x01|0x00|0x63|0x76|0x10|0x03|       99 = 0x10|0x02|0x48|0x13|0x07|0x00|0x63|0x00|0xd7|0x10|0x03|

#PUMP      0x0c  0x10|0x02|0x00|0x01|0x00|0x0c|0x1f|0x10|0x03|
#PUMPLO          0x10|0x02|0x00|0x01|0x0d|0x34|0x54|0x10|0x03|
#RSPFMT 
#RST 
#S1 


#VERS 




*/





/*

Startup against real panel

Debug:   RS Serial: Openeded serial port /dev/ttyUSB0
Debug:   RS Serial: Set serial port /dev/ttyUSB0 to blocking mode
Debug:   RS Serial: Set serial port /dev/ttyUSB0 io attributes
Debug:   AqualinkD: To 0x48 of type    Probe | HEX: 0x10|0x02|0x48|0x00|0x5a|0x10|0x03|


Debug:   AqualinkD: To 0x08 of type   Status | HEX: 0x10|0x02|0x08|0x02|0x00|0x00|0x00|0x00|0x00|0x1c|0x10|0x03|
Debug:   AqualinkD: To 0x48 of type    Probe | HEX: 0x10|0x02|0x48|0x00|0x5a|0x10|0x03|


Debug:   AqualinkD: To 0x08 of type   Status | HEX: 0x10|0x02|0x08|0x02|0x00|0x00|0x00|0x00|0x00|0x1c|0x10|0x03|
Debug:   AqualinkD: To 0x48 of type    Probe | HEX: 0x10|0x02|0x48|0x00|0x5a|0x10|0x03|


Debug:   AqualinkD: To 0x08 of type   Status | HEX: 0x10|0x02|0x08|0x02|0x00|0x00|0x00|0x00|0x00|0x1c|0x10|0x03|
Debug:   AqualinkD: To 0x48 of type    Probe | HEX: 0x10|0x02|0x48|0x00|0x5a|0x10|0x03|


Debug:   AqualinkD: To 0x08 of type   Status | HEX: 0x10|0x02|0x08|0x02|0x00|0x00|0x00|0x00|0x00|0x1c|0x10|0x03|
Debug:   AqualinkD: To 0x48 of type    Probe | HEX: 0x10|0x02|0x48|0x00|0x5a|0x10|0x03|


Debug:   AqualinkD: To 0x08 of type   Status | HEX: 0x10|0x02|0x08|0x02|0x00|0x00|0x00|0x00|0x00|0x1c|0x10|0x03|
Warning: RS Serial: BAD PACKET To 0x21 of type Unknown  | HEX: 0x10|0x02|0x21|0x3e|0x33|0x10|0x02|0x22|0x00|0x34|0x10|0x03|
Warning: RS Serial: Serial read bad Jandy checksum, ignoring
Warning: RS Serial: BAD PACKET To 0xfb of type PDA Hlig | HEX: 0x10|0x02|0xfb|0x10|0x02|0x08|0x02|0x00|0x00|0x00|0x00|0x00|0x1c|0x10|0x03|
Warning: RS Serial: Serial read bad Jandy checksum, ignoring
Debug:   AqualinkD: To 0x48 of type    Probe | HEX: 0x10|0x02|0x48|0x00|0x5a|0x10|0x03|


Debug:   AqualinkD: To 0x08 of type   Status | HEX: 0x10|0x02|0x08|0x02|0x00|0x00|0x00|0x00|0x00|0x1c|0x10|0x03|
Warning: RS Serial: BAD PACKET To 0x08 of type  Message | HEX: 0x10|0x02|0x08|0x03|0x00|0x20|0x41|0x49|0x52|0x20|0x54|0x45|0xfd|0x10|0x02|0x08|0x03|0x00|0x20|0x41|0x49|0x52|0x20|0x54|0x45|0x4d|0x50|0x20|0x39|0x35|0xdf|0x46|0x20|0x20|0x62|0x10|0x03|
Warning: RS Serial: Serial read bad Jandy checksum, ignoring












Debug:   AqualinkD: To 0x48 of type    Probe | HEX: 0x10|0x02|0x48|0x00|0x5a|0x10|0x03|
Debug:   AqualinkD: To 0x00 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x05|0x18|0x10|0x03|

Debug:   AqualinkD: To 0x48 of type Unknown  | HEX: 0x10|0x02|0x48|0x13|0x00|0x19|0x79|0x01|0x00|0x10|0x03|
  Command 0x00 = |0x19|0x79|0x01  25|121|1
Debug:   AqualinkD: To 0x00 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|

Warning: RS Serial: BAD PACKET To 0x48 of type Unknown  | HEX: 0x10|0x02|0x48|0x82|0x20|0x40|0x40|0x80|0x80|0x5c|0x10|0x03|
Warning: RS Serial: Serial read bad Jandy checksum, ignoring

Debug:   AqualinkD: To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x00|0x00|0x00|0x00|0x00|0x5c|0x10|0x03|


Debug:   AqualinkD: To 0x50 of type    Probe | HEX: 0x10|0x02|0x50|0x00|0x62|0x10|0x03|
Debug:   AqualinkD: To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x00|0x00|0x00|0x00|0x00|0x5c|0x10|0x03|


Debug:   AqualinkD: To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x00|0x00|0x00|0x00|0x00|0x5c|0x10|0x03|


Debug:   AqualinkD: To 0x60 of type    Probe | HEX: 0x10|0x02|0x60|0x00|0x72|0x10|0x03|
Debug:   AqualinkD: To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x00|0x00|0x00|0x00|0x00|0x5c|0x10|0x03|


Debug:   AqualinkD: To 0x00 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x05|0x18|0x10|0x03|
Debug:   AqualinkD: To 0x48 of type Unknown  | HEX: 0x10|0x02|0x48|0x13|0x00|0x19|0x79|0x01|0x00|0x10|0x03|
  Command 0x00 = |0x19|0x79|0x01  25|121|1


Debug:   AqualinkD: To 0x00 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|
Debug:   AqualinkD: To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x00|0x00|0x00|0x00|0x00|0x5c|0x10|0x03|


Debug:   AqualinkD: To 0x00 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|
Debug:   AqualinkD: To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x00|0x00|0x00|0x00|0x00|0x5c|0x10|0x03|


Debug:   AqualinkD: To 0x00 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|
Debug:   AqualinkD: To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x00|0x00|0x00|0x00|0x00|0x5c|0x10|0x03|


Debug:   AqualinkD: To 0x00 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|
Debug:   AqualinkD: To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x00|0x00|0x00|0x00|0x00|0x5c|0x10|0x03|


Debug:   AqualinkD: To 0x00 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|
Debug:   AqualinkD: To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x00|0x00|0x00|0x00|0x00|0x5c|0x10|0x03|


Debug:   AqualinkD: To 0x00 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|
Debug:   AqualinkD: To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x00|0x00|0x00|0x00|0x00|0x5c|0x10|0x03|


Debug:   AqualinkD: To 0x00 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|
Debug:   AqualinkD: To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x00|0x00|0x00|0x00|0x00|0x5c|0x10|0x03|


Debug:   AqualinkD: To 0x00 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|
Debug:   AqualinkD: To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x00|0x00|0x00|0x00|0x00|0x5c|0x10|0x03|


Debug:   AqualinkD: To 0x00 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|
Debug:   AqualinkD: To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x00|0x00|0x00|0x00|0x00|0x5c|0x10|0x03|


Debug:   AqualinkD: To 0x00 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|
Debug:   AqualinkD: To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x00|0x00|0x00|0x00|0x00|0x5c|0x10|0x03|


Debug:   AqualinkD: To 0x00 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|
Debug:   AqualinkD: To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x00|0x00|0x00|0x00|0x00|0x5c|0x10|0x03|



STARTUP

Jandy     To 0x48 of type    Probe | HEX: 0x10|0x02|0x48|0x00|0x5a|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x05|0x18|0x10|0x03|

Jandy     To 0x48 of type Unknown  | HEX: 0x10|0x02|0x48|0x13|0x00|0x19|0x79|0x00|0xff|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|

Jandy     To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x40|0x11|0x00|0x00|0x00|0xad|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|

Jandy     To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x40|0x11|0x00|0x00|0x00|0xad|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|

Jandy     To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x40|0x11|0x00|0x00|0x00|0xad|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|

Jandy     To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x40|0x11|0x00|0x00|0x00|0xad|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|

Jandy     To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x40|0x11|0x00|0x00|0x00|0xad|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|

Jandy     To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x40|0x11|0x00|0x00|0x00|0xad|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|

Jandy     To 0x48 of type   Status | HEX: 0x10|0x02|0x48|0x02|0x40|0x11|0x00|0x00|0x00|0xad|0x10|0x03|
Jandy   From 0x48 of type      Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x00|0x13|0x10|0x03|



Pump ON return
Debug:   RS Serial: To 0x00 of type              Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x0c|0x1f|0x10|0x03|
Debug:   RS Serial: To 0x48 of type   RSSA DevStatus | HEX: 0x10|0x02|0x48|0x13|0x03|0x00|0x01|0x0c|0x7d|0x10|0x03|

Pump OFF
Debug:   RS Serial: To 0x00 of type              Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x0c|0x1f|0x10|0x03|
Debug:   RS Serial: To 0x48 of type   RSSA DevStatus | HEX: 0x10|0x02|0x48|0x13|0x03|0x00|0x00|0x0c|0x7c|0x10|0x03|

Pump Flash
Debug:   RS Serial: To 0x00 of type              Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x0c|0x1f|0x10|0x03|
Debug:   RS Serial: To 0x48 of type   RSSA DevStatus | HEX: 0x10|0x02|0x48|0x13|0x03|0x00|0x01|0x0c|0x7d|0x10|0x03|


Pool Heat Enabeled
Debug:   RS Serial: To 0x00 of type              Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x11|0x24|0x10|0x03|
Debug:   RS Serial: To 0x48 of type   RSSA DevStatus | HEX: 0x10|0x02|0x48|0x13|0x03|0x00|0x02|0x11|0x83|0x10|0x03|

Spa HEat On
Debug:   RS Serial: To 0x00 of type              Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x13|0x26|0x10|0x03|
Debug:   RS Serial: To 0x48 of type   RSSA DevStatus | HEX: 0x10|0x02|0x48|0x13|0x03|0x00|0x02|0x13|0x85|0x10|0x03|

Solar Heat Off
Debug:   RS Serial: To 0x00 of type              Ack | HEX: 0x10|0x02|0x00|0x01|0x00|0x12|0x25|0x10|0x03|
Debug:   RS Serial: To 0x48 of type   RSSA DevStatus | HEX: 0x10|0x02|0x48|0x13|0x03|0x00|0x00|0x12|0x82|0x10|0x03|




*/

#endif
